user:file_search_path(sat, '/media/sf_Shared/Logic Programming/BEE/satsolver').
user:file_search_path(bee, '/media/sf_Shared/Logic Programming/BEE/beeCompiler').

:- use_module(sat(satsolver)).
:- use_module(bee(bCompiler)).
:- use_module('./bApplications/auxs/auxRunExpr',[runExpr/5]).
:- use_module('./bApplications/auxs/auxRunExprAll',[runExprAll/5]).

% Task 1

/*
 * kakuroVerify(Instance, Solution)  with mode kakuroVerify(+, +)
 * Will succeed if Solution is a legal solution to the kakuro Instance
 * We will use an auxilary predicate verifyAndAdd to help with the task.
 */


% Base case, both instance and solution are empty.
kakuroVerify([], []).				
kakuroVerify([Hint = List | Instance] , [Hint = Sol | Solution]):-
    bDecode:decodeIntArray(List, DecodedList),				% Decode
    verifyAndAdd(DecodedList, Sol, Sum),				% Testing the block
    Hint = Sum,								% Verifying Hint
    kakuroVerify(Instance, Solution).		



/*
 * verifyAndAdd(X, Y, Sum), will be used to calculate the sum of the block
 * The predicate will iterate over X and Y together making they are 'equal'
 * Sum will be used to save the sum of the block so far.
 */


% Base case, both lists musts be empty and the sum is 0.
verifyAndAdd([],[], 0).				
verifyAndAdd([X | Xs], [X | Ys], Sum):-		
    verifyAndAdd(Xs, Ys, Sum1),
    Sum is X + Sum1.


    

% Task 2

/*
 * kakuroEncode(Instance, Map, Constraints)  with mode kakuroEncode(+, -, -).
 * The predicate will encode the kakuro Instance to Bee constraints Constraints
 * Constraints will only be satisfiable if Map is a solution to the kakuro Instance. 
 * We will use auxilary predicates to help with the task.
 */


kakuroEncode(Instance, Instance, Constraints):-
    term_variables(Instance, VarList),				% get all variables in the Instance to VarList, no duplicates
    declare_ints(VarList, Constraints1),			% declare all variables with the new VarList (to avoid duplicates)
    kakuroEncode_aux(Instance, Constraints2),			% add kakuro constraints to all the blocks
    append(Constraints1, Constraints2, Constraints).
    


/*
 * declare_ints(List, Constraints), will be used to declare the ints to the BEE compiler
 * Predicate was learned in class.
 */

declare_ints([], []).
declare_ints([X | List], [new_int(X, 1, 9) | Constraints]):-
    declare_ints(List, Constraints).




/*
 * kakuroEncode_aux(Instance, Constraints), will be used to add BEE constraints,
 * such that the mapping of the Instance will be a legal solution to the kakuro Instance
 * The predicate will iterate the blocks of the instance, each iteration will add 2 constraints to Constraints
 * 1. A constraint to 'force' the integers in the block to be different from each other
 * 2. A constraint to 'force' the integers in the block to sum up to Hint.
 */


% Base case for an empty Instance.
kakuroEncode_aux([], []).
kakuroEncode_aux([Hint = List | Instance],  [int_array_allDiff(List) | [int_array_plus(List, Hint) | Constraints]]):-
    kakuroEncode_aux(Instance, Constraints).




% Task 3

/*
 * kakuroDecode(Map, Solution)  with mode kakuroDecode(+, -).
 * The predicate will decode the Map of variables generated by kakuroEncode to a kakuro Solution
 */


% Base case for an empty Map.
kakuroDecode([], []).
kakuroDecode([Hint = List | Map], [Hint = Sol | Solution]):-
    bDecode:decodeIntArray(List, Sol),				% Decoding a block
    kakuroDecode(Map, Solution).				% Recursive call to next block




% Task 4

/*
 * kakuroSolve(Instance, Solution)  with mode kakuroSolve(+, -).
 * The predicate will take a Kakuro instance, solve it using Bee, decode it and verify the solution generated. 
 * We will use a kakuroVerify predicate that also prints the solution, kakuroVerifyPrint(Instance, Solution).
 */


% Using runExpr, which was shown in class
kakuroSolve(Instance, Solution):-
    runExpr(Instance, Solution, kakuroEncode, kakuroDecode, kakuroVerifyPrint).


% Simply used to print the solution and ok / wrong.
kakuroVerifyPrint(Instance, Solution) :-
	(kakuroVerify(Instance, Solution) -> writeln(Solution:ok) ; writeln(Solution:wrong)).






% Task 5

/*
 * verify_killer(Instance, Solution)  with mode verify_killer(+, +).
 * The predicate will succeed if Solution is a legal killer sodoku solution for the instance Instance.
 * We will use auxilary predicates to help with the task and verify each "constraint" sepratly.
 */


verify_killer(killer(Instance), Solution):-
    ((
	length(Solution, 9),					% Solution should always be a 9x9 matrix
	verify_Hints(Instance, Solution),			% Verify that the hints are "the same" in the Instance and the Solution. 
	verify_RowCol(Solution, 1, Solution),			% Verify that the colums and rows all have the values 1...9 and are of length 9
	verify_Cubes(0, 0, Solution),				% Verify that the cubes all have values 1...9
	verify_KnightKingAbs(1, Solution)  			% Verify Knight, King moves and the absloute difference constraints.
    ) -> writeln(Solution:ok) ; writeln(Solution:wrong)).	% Printing the solution with ok / wrong



/*
 * verify_hints(Instance, Solution), will be used to to verify the Values that appear in Instance
 * also appear at the same position with the same value in Solution
 */

% Base case for no more hints
verify_Hints([], _).
verify_Hints([cell(I, J) = Value | Instance], Solution):-
    mapCell(I, J, Solution, Value),				% get the map Solution cell I, J and check that its Value = Value
    verify_Hints(Instance, Solution).



/*
 * mapCell(I, J, Map,  Value), will be used to get the Value of cell I, J in the matrix Map
 * the predicate was taken from the examples that came with the BEE compiler ( auxMatrix ).
 */

mapCell(I, J, Map, Value):-
    nth1(I, Map, Row),						% Get the Ith row of Map
    nth1(J, Row, Value).					% Get the Jth cell in that row


/*
 * getCol(J, Map, Col), will be used to get the Jth colum in the matrix Map
 * the predicate was taken from the examples that came with the BEE compiler ( auxMatrix ).
 */

getCol(_, [], []).
getCol(J, [Row | Map], [Value | Col] ):-
    nth1(J, Row, Value),					% Get Jth cell from current Row
    getCol(J, Map, Col), !.					% Iterate next row



/*
 * verify_RowCol(Rows, J, Solution), will be used to to verify the rows and colums of the Solution
 * Each Row and each Colum should be length of 9 and contain the values 1...9
 * The predicate will check if each Row and each Colum is a perumtation of [1...9]
 * Solution will be used to have a "whole" map for each iteration to get a colum from
 */

% Base case for no more rows, j should be 10 (since there should be 9 rows)
verify_RowCol([], 10, _).
verify_RowCol([Row | Rows], J, Solution):-
    getCol(J, Solution, Col), 					% Get the Jth colum of the matrix
    Permutation = [1,2,3,4,5,6,7,8,9],				
    permutation(Row, Permutation),				% Make sure the row is a permutaion of [1..9]
    permutation(Col, Permutation),				% Make sure the col is a permutaion of [1..9]
    J1 is J + 1,						% Increment J
    verify_RowCol(Rows, J1, Solution), !.			% Recursive call to check next rows



/*
 * mapCubeRow(J, Cube, Rows), will be used to iterate over Rows to form a List to represent a cube starting from cell J
 * The cube will always start from the first Row
 * The predicate will "split" each row to get the 3 values starting from cell J in the current Row
 */

% Base case for no more rows
mapCubeRow(_, [], []):- !.
mapCubeRow(J, Cube, [Row | Rows]):-
    length(StartCol, J),					% Set a list for all the value before cell J			
    length(CubeCol, 3),						% Set a Row for the cube
    append([StartCol, CubeCol, _], Row),			% "split" Row to get the cube row values
    mapCubeRow(J, Cube1, Rows),					% Iterate to get the next cube row
    append(Cube1, CubeCol, Cube).				% Combine all the rows to a single list Cube



/*
 * mapCube(I, J, Cube, Solution), will be used to create a list representing a 3x3 cube
 * The predicate will initiate the cube ( length of 3 )
 * Will "remove" the rows before I by "spliting" the map
 */


mapCube(I, J, Cube, Map):-
    length(StartRow, I), 					% Set a list for all the rows before row I
    length(CubeRows, 3),					% Set a cube to length of 3
    append([StartRow, CubeRows, _], Map),			% "split" Map to get the rows we need
    mapCubeRow(J, Cube, CubeRows).				% create a cube using only the rows needed



/*
 * verify_Cubes(I, J, Solution), will be used to to verify the cubes of the Solution
 * The predicate will iterate over J untill reaching J = 9, then increment I by 3 to make the next cubes
 * Each Cube should contain the values 1...9
 * The predicate will check if each cube is a perumtation of [1...9]
 */

% Base case for reach the end of a Row
verify_Cubes(9,0, _):- !.
verify_Cubes(I, 9, Solution):-					% Reach the end of the current rows 
    I1 is I + 3,						% Increment I to the start of the next set of cubes
    verify_Cubes(I1, 0, Solution), !.				% reset J to 0

verify_Cubes(I, J, Solution):-
    length(Cube, 9),						% Each cube should be a length 9 list
    mapCube(I, J, Cube, Solution),				% Get the cube
    permutation(Cube, [1,2,3,4,5,6,7,8,9]),			% Make sure the cube is a permutaion of [1..9]
    J1 is J + 3,						% Increment J to the next cube
    verify_Cubes(I, J1, Solution).		
   
 


/*
 * verify_KnightKingAbs(J, Solution), will be used to verify the knight, king and absloute difference constraints
 * The predicate will iterate over the Solution while keeping track of the colum its checking
 * Upong reaching J = 10, we will go to the next row in Solution and set J back to 1. 
 */

% Base case for an empty Map,  J should be 1
verify_KnightKingAbs(1, []):- !.
% Base case for reaching the end of a Row, J should be 10
verify_KnightKingAbs(10,[_ | Map]) :-
    verify_KnightKingAbs(1,  Map), !.						% Iterate next rows, and set J to 1


verify_KnightKingAbs(J, [[Value | Row] | Solution]):-
    knightKingAbs(J, [[Value | Row] | Solution], [King1 | [King2 | List]]),	% Get list that contains the values of knight king and abs constraints cells that are ahead of the current cell
    J1 is J + 1,								% Increment J
    verify_AllDiffFrom(Value, [King1 | [King2 | List]]),			% Verify all the values in the List are different from Value to fit constraints
    verify_Abs(Value, King1, King2),						% Verify the absloute constraints
    verify_KnightKingAbs(J1, [Row | Solution]).					% Recursive call to the next cell



/*
 * KnightKingAbs(J, Map, List), will be used to to generate a List of 8 values from Map
 * The values will be all the cells in the constraints description that are "ahead" in the marix (larger J(colum) with same I(row) or larger I(row))
 * The predicate will use mapCell predicate to get the Values of the needed cells
 * If mapCell fails (no such cell exists) we will store -1 / 0 depands on the needs
 */

knightKingAbs(J, [[Value | Row] | Map], List):-
    J1 is J + 1, J2 is J + 2, J3 is J - 1, J4 is J - 2,					% Set values from J to the cells needed by the constraints
    (mapCell(1, 2,  [[Value | Row] | Map], King1) -> ! ; King1 = -1),			% King1, King2 are used for 2 constraints, absloute value and king move
    (mapCell(2, J,  [[Value | Row] | Map], King2) -> ! ; King2 = -1),			% Setting them to -1, so that the lowest value possible in a cell (1) - (-1) = 2, to fit our constraints if no such cell exsists
    (mapCell(2, J1, [[Value | Row] | Map], King3) -> ! ; King3 = 0),			
    (mapCell(2, J3, [[Value | Row] | Map], King4) -> ! ; King4 = 0), 		
    (mapCell(2, J2, [[Value | Row] | Map], Knight1) -> ! ; Knight1 = 0),		% Getting values from the knight move cells 
    (mapCell(2, J4, [[Value | Row] | Map], Knight2) -> ! ; Knight2 = 0),
    (mapCell(3, J1, [[Value | Row] | Map], Knight3) -> ! ; Knight3 = 0),
    (mapCell(3, J3, [[Value | Row] | Map], Knight4) -> ! ; Knight4 = 0),		% Setting rest to 0 so we it will always be different from Value (1..9).
    List = [King1, King2, King3, King4, Knight1, Knight2, Knight3, Knight4].



/*
 * verify_AllDiffFrom(Value, List), will be used to to verify that all members of a List are different from Value
 * The predicate will iterate over List simply checking each Value =/= X in List
 */

% Base case for an empty List
verify_AllDiffFrom(_, []).
verify_AllDiffFrom(Value, [X | List]):-
    Value =\= X,
    verify_AllDiffFrom(Value, List).



/*
 * verify_Abs(Value, King1, King2), will be used verify that the absloute values of Value - King1/2 >= 2 
 */

verify_Abs(Value, King1, King2):-
    Abs1 = abs(Value - King1),			
    Abs2 = abs(Value - King2),
    Abs1 >= 2,
    Abs2 >= 2.


    
    


% Task 6

/*
 * encode_Killer(Instance, Map, Constraints), with mode encode_killer(+, -, -).
 * The predicate will unify Map with a represantation of the Instance.
 * The predicate will encode a set of BEE constraints such that the satisfying assignments for Constraints
 * correspong to solutions of the Killer Sodoku Instance
 * We will use a few auxilary predicates to help with the task
 */
   
encode_killer(killer(Instance), Map, Constraints):-
    length(Map, 9),											% Set number of rows
    killer_map(9, Map),											% Generate a Map with 9 cells in each row
    declare_map(Map, Constraints1),									% Declare the variables in the map to ints 1..9
    killer_hints(Instance, Map, Constraints2),								% Set constraints for the hints given in the instance
    allDiff_RowCol(Map, Map,  1, Constraints3),								% Set constraints such that each row and colum is a permutation of 1..9
    allDiff_Cubes(0, 0, Map, Constraints4),								% Set constraints such that each cube is a permutation of 1..9
    encode_KnightKingAbs(1, Map, Constraints5),								% Set knight, King moves and absloute constraints
    append([Constraints1, Constraints2, Constraints3, Constraints4, Constraints5], Constraints).	



/*
 * killer_map(Size, Map), will generate a rows for a Map, each row length of Size
 */

% Base case for an empty Map
killer_map(_, []):- !.
killer_map(Size, [Row | Map]):-
    length(Row, Size),							
    killer_map(Size, Map).



/*
 * declare_map(Map, Constraints), will be used to declare the integers for the BEE compiler
 */

% Base case for an empty Map
declare_map([],[]).
declare_map([Row | Map], Constraints):-
    declare_ints(Row, Constraints1),									% Declare integers of the current Row
    declare_map(Map, Constraints2),									% Iterate to the next Row
    append(Constraints1, Constraints2, Constraints).



/*
 * killer_hints(Instance, Map, Constraints), will be used to Set the constraints for the Instance hints
 * For each hint, will find the I, J cell in the map and set a constraints to make it equal to the hint
 */

% Base case for an empty Instance
killer_hints([], _, []).
killer_hints([cell(I, J) = Value | Instance], Map, [int_eq(Cell, Value) | Constraints]):-		
    mapCell(I, J, Map, Cell),
    killer_hints(Instance, Map, Constraints).



/*
 * allDiff_RowCol(Rows, Map, J, Constraints), will be used to Set the constraints such that each row and colum are a permutation of [1..9]
 * The predicate will iterate the rows, get the J colum and add a constraints for all vars in the Row and Col to be different
 */

% Base case for an Empty Rows, J should be 10 (reached the end of the map)
allDiff_RowCol([], _, 10, []).
allDiff_RowCol([Row | Rows], Map, J, [int_array_allDiff(Row) | [int_array_allDiff(Col) | Constraints]]):-
    getCol(J, Map, Col), 										% Get the Jth colum
    J1 is J + 1,											% Increment J
    allDiff_RowCol(Rows, Map, J1, Constraints).



/*
 * allDiff_Cubes(I, J, Map, Constraints), will be used to Set the constraints such that each cube is a permutation of [1..9]
 * The predicate will iterate over J with increments of 3, get the I, J cube and add constraints for all cubes vars to be differents
 * Increment I by 3 upon reaching J = 9 to get the next set of cubes
 */

% Base case for reaching the end of the Map
allDiff_Cubes(9, 0, _, []):- !.

% Base case for reaching the end of the current Rows
allDiff_Cubes(I, 9, Map, Constraints):-
    I1 is I + 3,											% Increment I to get next set of rows
    allDiff_Cubes(I1, 0, Map, Constraints), !.

allDiff_Cubes(I, J, Map, [int_array_allDiff(Cube) | Constraints]):-
    length(Cube, 9),											% Set Cube length (3x3 = 9)
    mapCube(I, J, Cube, Map),										% Get 3x3 Cube starting at cell I , J
    J1 is J + 3,											% Increment J
    allDiff_Cubes(I, J1 , Map, Constraints).




/*
 * encode_KnightKingAbs(J, Map, Constraints), will be used to Set the constraints for the Knight, King and absloute constraints
 * The predicate will iterate over all the cells of the map, adding constraints for these moves
 */ 

% Base case for reaching the end of the Map
encode_KnightKingAbs(10, [[] | []], []):- !.

% Reached the end of a row, Iterate next row and reset J to 1
encode_KnightKingAbs(10, [_ | Map], Constraints):-
    encode_KnightKingAbs(1, Map, Constraints), !.

encode_KnightKingAbs(J, [[Value | Row] | Map], Constraints):-
    knightKingAbs(J, [[Value | Row] | Map], [King1 | [King2 | List]]), 					% Get a list with the knight , king and abs moves values
    allDiffFrom(Value, [King1 | [King2 | List]], Constraints1),						% Get constraints such that all of these cells are different from Value
    absConstraints(Value, King1, King2, Constraints2),							% Get absloute constraints 
    J1 is J + 1,											% Increment J
    encode_KnightKingAbs(J1, [Row | Map], Constraints3),						% Iterate next cell
    append([Constraints1, Constraints2, Constraints3], Constraints).
    

/*
 * allDiffFrom(Value, List, Constraints), will be used to set constraints such that all values in List are different from Value
 * The predicate will iterate over the list, each iteration adding a constraints such that Value =/= X
 */ 

% Base case for reaching the end of the list
allDiffFrom(_ , [], []). 
allDiffFrom(Value, [X | List], [int_neq(Value, X) | Constraints]):-
    allDiffFrom(Value, List, Constraints), !.



/*
 * absConstraints(Value, Abs1, Abs2, Constraints), will be used to set constraints for the absloute difference constraint
 * The predicate will decalre 2 new ints for each Abs, Diffi for Value - Absi, and diffii for the absloute value of Diffi
 */ 
absConstraints(Value, Abs1, Abs2, Constraints):-
	Constraints = [new_int(Diff1,-10, 10), new_int(Diff11, 1, 10), new_int(Diff2, -10, 10), new_int(Diff22, 1, 10),
		       int_plus(Value, -Abs1, Diff1), int_abs(Diff1, Diff11), int_geq(Diff11, 2),
		       int_plus(Value, -Abs2, Diff2), int_abs(Diff2, Diff22), int_geq(Diff22, 2)].





% Task 7

/*
 * decode_killer(Map, Solution)  with mode decode_killer(+, -).
 * The predicate will be used to the decode a Map reprsenting a killer soduko solution
 * The predicate will create from the given Map a corresponding solution in the format of a 9x9 matrix of 81 assignment constraints
 */

% Base case for an empty Map
decode_killer([], []).
decode_killer([Row | Map], [Sol | Solution]):-
    bDecode:decodeIntArray(Row, Sol),				% Decode a row using BEE
    decode_killer(Map, Solution).				% iterate to the next row





% Task 8

/*
 * all_killer(Instance, Solutions), with mode all_killer(+, -).
 * Given an instance of a Killer Sudoku puzzle, unifies Solutions with a list
 * of all possible solutions to Instance.
 * Killer Sudoku instance should have exactly one solution
 * we will use an auxilary predicates to help with setting the Relevants Vars
 */

all_killer(Instance, Solutions):-
    runExprAll(Instance, Solutions, encode, decode_killer, verify_killer).


/*
 * encode(Instance, Map,ReleventInts, Solution), will be used to encode the Instance and set the Relevents Vars
 * The predicate will create an empty list for the Boolean variables
 * And use an auxilary predicate GetRelInts to set the relevent Integer variables
 */

encode(Instance, Map, (RelevantBools, RelevantInts), Constraints):-
    encode_killer(Instance, Map, Constraints),			% Encode Instance
    RelevantBools = [],						% There are no relevent Booleans
    getRelInts(Map, RelevantInts).				% Get and set relevant Int variables


/*
 * getRelInts(Map, RelevantInts), will be used to get all the relevant int vars into a single list RelevantInts
 * The predicate will iterate over the map (a matrix) and append all of its rows, creating a single list from the matrix
 */

% Base case for empty map
getRelInts([], []).
getRelInts([Row | Map], RelevantInts):-
    getRelInts(Map, RelevantInts1), 
    append(Row, RelevantInts1, RelevantInts). 
